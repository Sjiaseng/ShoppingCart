1. Web Tags
@Controller [return page only]
@ResponseBody [return data not page]

@RestController [fetch data from server to client -> return data]
@RequestMapping() -> Map the web index, parameter or url

-> @Service [for service]
-> @Component [for model] + @Entity [if using repo] + @Id [for primary key] + @GeneratedValue(strategy = GenerationType.IDENTITY) [for autogenerated section]
-> @Controller [for controller]
-> @Repository [for repository]

2. Dependency
Find dependencies in Maven Repositories [version]
Copy dependency code into the pom.xml then Sync Build

3. Controller -> Receive Request from client only (Dont Include Business Logic)
   View -> Return Pages
   Model -> Data
   Service -> Business Logic
   *Controller -> coordinates the overall flow 
   - Taking inputs from the user
   - Involving the model and services as needed
   - Send appropriate data back to the view for display.

   # Repo Layer -> handle database connectivity and flow of data from database

4. lombok dependencies
-> @Data [create data for model after variable initiated]
-> @AllArgsConstructor [create constructor for model automatically]
-> @NoArgsConstructor [constructor with no argument - default constructor]
   Sometimes Doesn't Work D;

5. Changing Port Configuration
-> java/com/something/something/resources/application.properties
server.port = 8081 [any working number]

6. Set Getter, Setter and Constructor in VS Code -> Right Click > Source Actions [at least 1 variable]

7. Run Server -> postman > New > HTTP
Include the localhost:port/requestmapping/id [include ID to view one object -> method must be included in controller]

8. @PathVariable included when the variable is used in the mapping section [dynamic data like id "103" or etc..]
   
   @RequestMapping("/products/{prodId}")
   public Product getProductById(@PathVariable int prodId){
       return service.getProductById(prodId);
   }

9.Stream Handling

   // normal get
   public Product getProductById(int prodId) {
       return products.stream()
           .filter(p -> p.getProdId() == prodId)
           .findFirst().get();
   }

   // default value if value not found
   public Product getProductById(int prodId) {
    return products.stream()
        .filter(p -> p.getProdId() == prodId)
        .findFirst().orElse(new Product(100, "No Item", 0));
   }

10. jackson package - conversion of Java objects into json format and vice versa [handle data format also]
    @RequestBody -> from client to server or server to client. [get whole object / json file]
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-mm-yyyy")
    @RequestPart -> Obtain multiple part of data [ex. a body info & an image to be uploaded into database]
    *Note: Object and Image are different Type of Data which have to Separately Processed for different file type

    MultipartFile -> File Type for Image
    
   Example:
   @PostMapping("/products")
    public void addProduct(@RequestBody Product prod){
        service.addProduct(prod);
    }

11.@GetMapping -> Handle GET Request 
   @PostMapping -> Handle POST Request
   @PutMapping -> Handle PUT Request
   @DeleteMapping -> Handle DELETE Request
   @RequestMaping -> for RestAPI [Handle Multiple Request -> need state method type if possible to avoid confusion].

12. Include Dependencies:
    -> Spring Boot Starter Data Jpa
    -> h2database

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<scope>runtime</scope>
		</dependency>


    # Include URL in application.properties [adjust according database used and settings]
    # H2 database configuration
    spring.datasource.url=jdbc:h2:mem:simplewebapp [temporary memory - delete entries after restart // can change to permenant also]
    spring.datasource.driver-class-name=org.h2.Driver
    spring.datasource.username=testing
    spring.datasource.password=123

    spring.jpa.show-sql=true [for debug purpose]
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.defer-datasource-initialization=true [install the sql data in the resources section -> add .sql file with SQL commands]

    - access h2 -> localhost:8080/h2-console
    - change jdbc url -> ur databse name [behind jdbc:h2:mem:[here]]

13. @Repository
    public interface ProductRepo extends JpaRepository<Object, DataTypeofPrimaryKey>{}
    Next, autowire the repo interface into the service class.

    Basic:
    save(Product product): Saves a given product.
    findById(Integer id): Retrieves a product by its ID.
    findAll(): Returns all products.
    deleteById(Integer id): Deletes the product with the specified ID.
    count(): Returns the number of products.

    customize function: List<Product> findByName(String name); [include in the repo/interface section]

14. Resolving Cross Origin Error (frontend - port 5173, backend port 8080)
    @CrossOrigin in controller section.

15. Backend and Frontend Working Principle

Modification in Json File:

axios.put('http://localhost/api/products/1', {
   name: 'New Product Name',
   price: 100
});

Modification in Database:

@PutMapping("/api/products/{id}")
public ResponseEntity<Product> updateProduct(@PathVariable Long id, @RequestBody Product productDetails) {
    Product product = productRepository.findById(id).orElseThrow(() -> new ResourceNotFoundException("Product not found"));
    
    product.setName(productDetails.getName());
    product.setPrice(productDetails.getPrice());
    
    Product updatedProduct = productRepository.save(product);
    return ResponseEntity.ok(updatedProduct);
}

External API:

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private RestTemplate restTemplate;

    public void syncWithExternalApi() {
        // Call the external API
        ResponseEntity<Product[]> response = restTemplate.getForEntity("http://externalapi.com/products", Product[].class);
        Product[] productsFromApi = response.getBody();

        // Update the database with the products from the external API
        for (Product product : productsFromApi) {
            productRepository.save(product);
        }
    }
}

16. ResponseEntity -> Give Status Code [controller]

    @GetMapping("/products")
    public ResponseEntity<List<Product>> getAllProducts(){
        return new ResponseEntity<>(service.getAllProducts(), HttpStatus.OK);
    }

    @GetMapping("/product/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable int id){

        Product product = service.getProductById(id);
        if(product != null){
            return new ResponseEntity<>(product, HttpStatus.OK);
        }else{
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        
    }

17. @Lob -> for big data type like byte[] etc... images storage

18. @Query(SQL query here) -> For SQL Query (Interface / Repository Section)

    @Repository
    public interface ProductRepo extends JpaRepository<Product, Integer> {

        @Query(SQL query here)
        List<Product> searchProducts(String keyword);
    }
    
    Note: @RequestParam for Searching.

    @GetMapping("/product/search")
    public ResponseEntity<List<Product>> searchProducts(@RequestParam String keyword){
        
    }

    Example of Search Link:
    http://localhost:8080/api/products/search?keyword=test